<html>
    <style>
        #data, #data li, #data div, #data code, #data span, #data a, #controls,
        #controls li {
            display: block;
            overflow: hidden;
        }
        #data, #controls {
            margin: 0;
            padding: 0;
        }
        #data li{
            border: 1px solid rgb(153, 174, 193);
            padding: 3px;
            background-color: rgb(208, 228, 246);
            margin-bottom: 2px;
        }
        #data div {
            background-color: bisque;
            cursor: pointer;
            padding: 3px;
        }
        #data li.sc200 div {
            background-color: #7daa7a;
        }
        #data li.sc500 div {
            background-color: #e19687;
        }
        #data pre {
            display: none;
            overflow: auto;
        }
        #data span, #data a{
            float: left;
        }
        #data span {
            min-width: 500px;
        }
        #data a {
            color: rgb(245, 226, 226);
            font-weight: bolder;
            text-shadow: 0px 0px 2px #000000;
        }
        #controls {
            margin-bottom: 20px;
            background-color: #f5fbf4;
            border-bottom: 2px solid #145a09;
        }
        #controls li {
            float: right;
        }
        #controls li.act {
            cursor: pointer;
        }
        #control-space-right {
            margin-right: 50px;
        }
    </style>
    <body>
        <ul id="controls">
            <li id="control-space-right">&nbsp;</li>
            <li class="act" id="control-clear">⎚</li>
        </ul>
        <ul id="data"></ul>
        <script>
            const decompressBlob = async(base64) => {
                const blob = await (await fetch(`data:application/octet-stream;base64,${base64}`)).blob();
                let ds = new DecompressionStream('gzip');
                const dss = blob.stream().pipeThrough(ds);
                const dsb = await new Response(dss).blob();
                return await dsb.text();
            }
            const bodyTrans = async(data, params, type) => {
                if (
                    data &&
                    params
                ) {
                    if (params.headers.findIndex((h) => h.indexOf('application/json') >= 0) >= 0) {
                        try {
                            if (type === 'response' && params.headers.findIndex((h) => h.indexOf('gzip') >= 0) >= 0) {
                                const c = await decompressBlob(data);
                                return JSON.parse(c);
                            }
                            return JSON.parse(window.atob(data));
                        } catch (e) {
                            return window.atob(data);
                        }
                    } else if (params.headers.findIndex((h) => h.indexOf('xml') >= 0) >= 0) {
                        if (type === 'response' && params.headers.findIndex((h) => h.indexOf('gzip') >= 0) >= 0) {
                            return await decompressBlob(data);
                        }
                        return window.atob(data);
                    }
                }
                return data;
            };
            const proto = (location.protocol === 'http:' && 'ws') || 'wss';
            ws = new WebSocket(`${proto}://${location.hostname}:${window.location.port}/ws`);
            ws.addEventListener('message', async({data}) => {
                const {idx, request: rq, response: resp} = JSON.parse(data);
                const request = (() => {
                    try {
                        const s = atob(rq);
                        const ss = s.split('\r').join('').split('\n').shift().split(' ');
                        return {method: ss[0], url: ss[1], text: s};
                    } catch (e) {
                        console.error(e);
                    }
                })();
                const response = (() => {
                    try {
                        const s = atob(resp);
                        const ss = s.split('\r').join('').split('\n').shift().split(' ');
                        return {statusCode: ss[1], url: ss[1], text: s};
                    } catch (e) {
                        console.error(e);
                    }
                })();
                const cont = document.getElementById("data");
                const textSpan = document.createTextNode(
                    `${idx + 1}: ${request.method} ${request.url}; ${response.statusCode};`
                );
                const textCode = document.createTextNode(
                    JSON.stringify({
                        request: request.text,
                        response: response.text
                    }, null, 2)
                );
                const li = document.createElement('li');
                li.classList.add(`sc${response.statusCode}`);
                const span = document.createElement('span');
                const div = document.createElement('div');
                const code = document.createElement('pre');
                span.appendChild(textSpan);
                const repeat = document.createElement('a');
                repeat.appendChild(document.createTextNode('↻'));
                div.addEventListener('click', (e) => {
                    if (code.style.display !== 'block') {
                        code.style.display = 'block';
                    } else {
                        code.style.display = 'none';
                    }
                });
                repeat.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const xhttp = new XMLHttpRequest();
                    xhttp.open('GET', `repeat/${idx}`, true);
                    xhttp.send();
                });
                code.appendChild(textCode);
                div.appendChild(span);
                div.appendChild(repeat);
                li.appendChild(div);
                li.appendChild(code);
                cont.appendChild(li);

                document
                    .getElementById("control-clear")
                    .addEventListener('click', () => {
                        cont.childNodes.forEach((child) => {
                            child.remove();
                        });
                        const xhttp = new XMLHttpRequest();
                        xhttp.open('GET', `reset`, true);
                        xhttp.send();
                    });
            });
        </script>
    </body>
</html>