<html>
    <style>
        #data, #data li, #data div, #data code, #data span, #data a, #controls,
        #controls li {
            display: block;
            overflow: hidden;
        }
        #data, #controls {
            margin: 0;
            padding: 0;
        }
        #data li{
            border: 1px solid rgb(153, 174, 193);
            padding: 3px;
            background-color: rgb(208, 228, 246);
            margin-bottom: 2px;
        }
        #data div {
            background-color: bisque;
            cursor: pointer;
            padding: 3px;
        }
        #data li.sc200 div {
            background-color: #7daa7a;
        }
        #data li.sc500 div {
            background-color: #e19687;
        }
        #data pre {
            display: none;
            overflow: auto;
        }
        #data span, #data a{
            float: left;
        }
        #data span {
            min-width: 500px;
        }
        #data a {
            color: rgb(245, 226, 226);
            font-weight: bolder;
            text-shadow: 0px 0px 2px #000000;
        }
        #controls {
            margin-bottom: 20px;
            background-color: #f5fbf4;
            border-bottom: 2px solid #145a09;
        }
        #controls li {
            float: right;
        }
        #controls li.act {
            cursor: pointer;
        }
        #control-space-right {
            margin-right: 50px;
        }
    </style>
    <body>
        <ul id="controls">
            <li id="control-space-right">&nbsp;</li>
            <li class="act" id="control-clear">⎚</li>
        </ul>
        <ul id="data"></ul>
        <script>
            const endings = {n: '\n\n', rn: '\r\n\r\n'};
            const lineEndings = {n: '\n', rn: '\r\n'};
            const decompressBlob = async(base64) => {
                const blob = await (await fetch(`data:application/octet-stream;base64,${base64}`)).blob();
                let ds = new DecompressionStream('gzip');
                const dss = blob.stream().pipeThrough(ds);
                const dsb = await new Response(dss).blob();
                return await dsb.text();
            }
            const bodyHeaders = (data) => {
                const rn = data.indexOf(endings.rn);
                const r = data.indexOf(endings.n);
                const ending = ((rn > -1) && 'rn') || 'n';
                const pos = ((rn > -1) && rn) || r;
                let body = data
                    .slice(pos + ((rn > -1) && 4) || 2);
                if (body.indexOf(endings[ending]) > -1) {
                    body = body.slice(0, (((rn > -1) && 4) || 2) * -1);
                }
                const ph = data
                    .toLowerCase()
                    .slice(0, pos)
                    .split(lineEndings[ending]);
                const fa = ph.shift();
                const headers = ph
                    .map((v) => v.trim().split(':'))
                    .reduce((h, [k, v]) => ({...h, [k]: v?.trim()}), {});

                return {
                    headers,
                    body,
                    json: headers['content-type']?.indexOf('application/json') > -1,
                    fa: fa.split(' ').map((v) => v.trim())
                };
            };
            const proto = (location.protocol === 'http:' && 'ws') || 'wss';
            ws = new WebSocket(`${proto}://${location.hostname}:${window.location.port}/ws`);
            ws.addEventListener('message', async({data}) => {
                const {idx, request: rq, response: resp} = JSON.parse(data);
                const request = (() => {
                    try {
                        const s = atob(rq);
                        const hb = bodyHeaders(s);
                        if (hb.json && hb.body) {
                            hb.body = JSON.parse(hb.body);
                        }
                        return {method: hb.fa[0], url: hb.fa[1], ...hb};
                    } catch (e) {
                        console.error(e);
                    }
                })();
                const response = await(async() => {
                    try {
                        const s = atob(resp);
                        const hb = bodyHeaders(s);
                        const db = await (async() => {
                            if (!hb.headers['content-encoding'] || hb.headers['content-encoding'].indexOf('gzip') === -1) {
                                if (hb.json && hb.body) {
                                    return JSON.parse(hb.body);
                                } else {
                                    return hb.body;
                                } 
                            } else {
                                try {
                                    const txt = await decompressBlob(
                                        btoa(
                                            hb.body
                                                .split('\r\n')
                                                .slice(1)
                                                .filter((v, idx) => !(idx % 2))
                                                .join('')
                                        )
                                    );
                                    if (hb.json && hb.body) {
                                        return JSON.parse(txt);
                                    }
                                    return txt;
                                } catch (e) {
                                    return b;
                                }
                            }
                        })();
                        return {statusCode: hb.fa[1], url: hb.fa[1], headers: hb.headers, body: db};
                    } catch (e) {
                        console.error(e);
                    }
                })();
                const cont = document.getElementById("data");
                const textSpan = document.createTextNode(
                    `${idx + 1}: ${request.method} ${request.url}; ${response.statusCode};`
                );
                const textCode = document.createTextNode(
                    JSON.stringify({
                        request: {
                            headers: request.headers,
                            body: request.body
                        },
                        response: {
                            headers: response.headers,
                            body: response.body
                        }
                    }, null, 2)
                );
                const li = document.createElement('li');
                li.classList.add(`sc${response.statusCode}`);
                const span = document.createElement('span');
                const div = document.createElement('div');
                const code = document.createElement('pre');
                span.appendChild(textSpan);
                const repeat = document.createElement('a');
                repeat.appendChild(document.createTextNode('↻'));
                div.addEventListener('click', (e) => {
                    if (code.style.display !== 'block') {
                        code.style.display = 'block';
                    } else {
                        code.style.display = 'none';
                    }
                });
                repeat.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const xhttp = new XMLHttpRequest();
                    xhttp.open('GET', `repeat/${idx}`, true);
                    xhttp.send();
                });
                code.appendChild(textCode);
                div.appendChild(span);
                div.appendChild(repeat);
                li.appendChild(div);
                li.appendChild(code);
                cont.appendChild(li);

                document
                    .getElementById("control-clear")
                    .addEventListener('click', () => {
                        cont.childNodes.forEach((child) => {
                            child.remove();
                        });
                        const xhttp = new XMLHttpRequest();
                        xhttp.open('GET', `reset`, true);
                        xhttp.send();
                    });
            });
        </script>
    </body>
</html>